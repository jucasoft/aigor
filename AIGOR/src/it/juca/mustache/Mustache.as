package it.juca.mustache {import flash.utils.describeType;import mx.collections.ArrayCollection;public class Mustache {    public function Mustache() {        //trace("mustache instantiated!");    }    public var otag:String = "{{";    public var ctag:String = "}}";    private var pragmas:Object = {};    private var buffer:Array = [];    private var pragmas_implemented:Object = {"IMPLICIT-ITERATOR": true};    private var send:Function;    public function to_html(template:String, view:Object, partials:Object = null, send_fun:Function = null):String {        if (send_fun != null) {            send = send_fun;        }        else {            var that:Mustache = this;            send = function (line:*):* {                if (line != "") {                    that.buffer.push(line);                }            }        }        render(template, view, partials);        if (send_fun == null) {            return buffer.join("\n");        }        return null;    }    private function render(template:String, context:Object, partials:Object = null, in_recursion:Boolean = false):String {//        trace("render() " + template);        var ret:String;        buffer = [];        if (!includes("", template)) {            if (in_recursion) {                return template;            }            else {                send(template);                return "";            }        }        if (!in_recursion) {            buffer = [];        }        template = render_pragmas(template);        var html:String = render_section(template, context, partials);        if (in_recursion) {            ret = render_tags(html, context, partials, in_recursion);            trace("render_tags: " + ret);            return ret;        }        render_tags(html, context, partials, in_recursion);        return html;    }    private function render_pragmas(template:String):String {        if (!includes("%", template)) {            return template;        }        var that:Mustache = this;        var regex:RegExp = new RegExp(otag + "%([\\w_-]+) ?([\\w]+=[\\w]+)?" + ctag);        return template.replace(regex, function (match:*, pragma:*, options:*):* {            if (!pragmas_implemented[pragma]) {                throw new Error("This implementation of mustache doesn't understand the '" + pragma + "' pragma.");            }            that.pragmas[pragma] = {};            if (options) {                var opts:Array = options.split("=");                that.pragmas[pragma][opts[0]] = opts[1];            }            return "";        });    }    private function render_partial(name:String, context:Object, partials:Object):String {        if (!partials || !partials[name]) {            throw new Error("Unknown partial '" + name + "'.");        }        //			if(typeof(context[name]) != "object")        //			{        //				trace("-- render_partial, cut out! " + context[name]);        //				return partials[name];        //			}        return render(partials[name], context, partials, true);    }    private function render_section(template:String, context:Object, partials:Object):String {        if (!includes("#", template) && !includes("^", template)) {            return template;        }        var that:Mustache = this;        var regex:RegExp = new RegExp(otag + "(\\^|\\#)(.+)" + ctag + "\\s*([\\s\\S]+?)" + otag + "\\/\\2" + ctag + "\\s*", "mg");        return template.replace(regex, function (match:*, type:*, name:*, content:*):* {            var value:* = normalizzeData(that.find(name, context));            if (type == "^") {                if (!value || value is Array && value.length == 0) {                    return render(content, context, partials, true);                } else {                    return "";                }            } else if (type == "#") {                if (value is Array) {                    return that.map(value,function (row:*):* {                        return that.render(content, that.merge(context, that.create_context(row)), partials, true);                    }).join("");                } else if (value is Function) {                    return value.call(context, content, function (text:*):* {                        return that.render(text, context, partials, true);                    })                } else if (!(value is Boolean) && !(value is String)) {                    return that.render(content,                            that.merge(context, that.create_context(value)), partials, true);                } else if (value) {                    return that.render(content, context, partials, true);                } else {                    return "";                }            }        });    }    //il sistema non è in grado di gestire arraycollection questo metodo trasforma in array se un iList    private function normalizzeData(value:Object):* {        if (value is ArrayCollection) {            var array:Array = [];            for (var i:int = 0; i < value.length; i++) {                array.push(value.source[i]);            }            return array;        } else {            return value;        }        return null;    }    private function render_tags(template:String, context:Object, partials:Object, in_recursion:Boolean):String {        var that:Mustache = this;        var new_regex:Function = function ():* {            return new RegExp(that.otag + "(=|!|>|\\{|%)?([^\/#\^\]+?)\\1?" + that.ctag + "+", "g");        }        var regex:RegExp = new_regex();        var lines:Array = template.split("\n");        for (var i:int = 0; i < lines.length; i++) {            lines[i] = String(lines[i]).replace(regex, function (match:*, operator:*, name:*):* {//                trace(match + ":" + operator + ":" + name);                switch (operator) {                    case "!":                        return "";                    case "=":                        that.set_delimiters(name);                        regex = new_regex();                        return "";                    case ">":                        return that.render_partial(that.trim(name), context, partials);                    case "{":                        return that.find(name, context);                    default:                        return that.escape(that.find(name, context));                }            });            if (!in_recursion) {                this.send(lines[i]);            }        }        if (in_recursion) {            return lines.join("\n");        }        return "";    }    private function set_delimiters(delimiters:String):void {        var dels:Array = delimiters.split(" ");        otag = escape_regex(dels[0]);        ctag = escape_regex(dels[1]);    }    private function escape_regex(text:String):String {        if (!arguments.callee.sRE) {            var specials:Array = [                '/', '.', '*', '+', '?', '|',                '(', ')', '[', ']', '{', '}', '\\'            ];            arguments.callee.sRE = new RegExp('(\\' + specials.join('|\\') + ')', 'g');        }        return text.replace(arguments.callee.sRE, '\\$1');    }    private function find(name:String, context:Object):* {        name = trim(name);        if (typeof context[name] === "function") {            return context[name].apply(context);        }        if (context[name] != undefined) {            return context[name];        }        return "";    }    private function includes(needle:Object, haystack:Object):Boolean {        return haystack.indexOf(otag + needle) != -1;    }    private function escape(s:*):String {        return ((s == null) ? "" : s).toString().replace(/&(?!\w+;)|["<>\\]/g, function (s:*):* {            switch (s) {                case "&":                    return "&amp;";                case "\\":                    return "\\\\";                    ;                case '"':                    return '\"';                    ;                case "<":                    return "&lt;";                case ">":                    return "&gt;";                default:                    return s;            }        });    }    private function merge(a:Object, b:Object):Object {//        trace("merge()");        var _new:Object = {};        var accessor:XMLList        mergeUtyl(a, _new);        mergeUtyl(b, _new);        for (var name:String in _new) {//            trace("new: " + name + "=" + _new[name]);        }        return _new;    }    private function mergeUtyl(souce:Object, destination:Object):void {//        trace("mergeUtyl()");        var accessor:XMLList = XML(describeType(souce)).accessor;        var name:String        if (accessor.length() > 0) {            for (var j:int = 0; j < accessor.length(); j++) {                var i:XML = accessor[j];                if (souce.hasOwnProperty(i.@name)) {//                    trace("souce: " + i.@name + "=" + souce[i.@name]);                    destination[i.@name] = souce[i.@name];                }            }        } else {            for (name in souce) {                if (souce.hasOwnProperty(name)) {//                    trace("souce: " + name + "=" + souce[name]);                    destination[name] = souce[name];                }            }        }    }    private function create_context(_context:*):Object {        var aval:String;//        trace("create_context()");        for (aval in _context) {//            trace("-- " + aval + ": " + _context[aval]);        }        if (is_object(_context)) {            return _context;        } else if (pragmas["IMPLICIT-ITERATOR"]) {            var iterator:String = pragmas["IMPLICIT-ITERATOR"].iterator || ".";            var ctx:Object = {};            ctx[iterator] = _context;            return ctx;        }        return new Object();    }    private function is_object(a:*):Boolean {        return a && !(a is Array);        //return a && typeof a == "object";    }    private function is_array(a:*):Boolean {        return a is Array;    }    private function trim(s:String):String {        return s.replace(/^\s*|\s*$/g, "");    }    private function map(array:Array, fn:Function):Array {//        trace("map()")        if (array.map is Function) {//            trace("array.map(fn)");            var ret:Array = array.map(fn);//            trace("ret:Array : " + ret);            return ret;        } else {            var val:*;            var r:Array = [];            var l:int = array.length;            for (var i:int = 0; i < l; i++) {                val = fn(array[i]);                r.push(fn(array[i]));            }//            trace("return r:Array : " + r);            return r;        }    }}}